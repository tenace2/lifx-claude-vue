#!/usr/bin/env node

import { McpServer, ResourceTemplate } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'
import stripJsonComments from 'strip-json-comments'
import { readFileSync, existsSync } from 'fs'
import { dirname, join, resolve } from 'path'
import { fileURLToPath } from 'url'
import { z } from 'zod'
import _ from 'lodash'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const LIFX_API_BASE_URL = 'https://api.lifx.com/v1'

const start = async (cliApiToken) => {
  log(`LIFX API MCP Server v${getPackageVersion()} starting…`, true)

  config = loadConfig()

  apiToken = config.apiToken || process.env.CONFIG_API_TOKEN || cliApiToken

  if (!apiToken) {
    log('Error: LIFX API token is required. Provide it via config file (~/.lifx-api-mcp-server.jsonc), CONFIG_API_TOKEN env var, or CLI argument.', true)
    exit(1)
  }

  log('Initializing MCP server…')
  server = new McpServer({
    name: 'LIFX API MCP Server',
    version: getPackageVersion(),
    description: 'MCP server for controlling LIFX devices via the HTTP API',
    homepage: 'https://github.com/furey/lifx-api-mcp-server', // Placeholder URL
    license: 'MIT',
    vendor: {
      name: 'Generated by AI', // Modify as needed
      url: ''
    }
  }, {
    instructions // Updated instructions below
  })

  server.fallbackRequestHandler = async request => {
    log(`Received request for undefined method: ${request.method}`, true)
    const error = new Error(`Method '${request.method}' not found`)
    error.code = JSONRPC_ERROR_CODES.METHOD_NOT_FOUND
    throw error
  }

  log('Registering MCP resources…')
  registerResources(server)

  log('Registering MCP prompts…')
  registerPrompts(server)

  log('Registering MCP tools…')
  registerTools(server)

  log('Creating stdio transport…')
  transport = new StdioServerTransport()

  log('Connecting MCP server transport…')
  await server.connect(transport)

  log('LIFX API MCP Server running.', true)
  return true
}

const makeApiRequest = async ({ method, path, body, query }) => {
  let url = `${LIFX_API_BASE_URL}${path}`

  if (query) {
    const queryParams = new URLSearchParams(query)
    url += `?${queryParams.toString()}`
  }

  const options = {
    method: method.toUpperCase(),
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'Accept': 'application/json'
    }
  }

  if (body && Object.keys(body).length > 0) {
    options.headers['Content-Type'] = 'application/json'
    options.body = JSON.stringify(body)
    log(`API Request: ${options.method} ${url} with body: ${JSON.stringify(body)}`)
  } else {
    log(`API Request: ${options.method} ${url}`)
  }

  const response = await fetch(url, options)

  const limit = response.headers.get('X-RateLimit-Limit')
  const remaining = response.headers.get('X-RateLimit-Remaining')
  const reset = response.headers.get('X-RateLimit-Reset')
  if (limit) log(`Rate Limit: ${remaining}/${limit} remaining, resets at ${new Date(reset * 1000).toLocaleTimeString()}`)

  if (!response.ok) {
    let errorBody
    try {
      errorBody = await response.json()
    } catch (e) {
      errorBody = await response.text()
      errorBody = { error: `HTTP Error: ${response.status} ${response.statusText}. Response: ${errorBody}` }
    }
    log(`API Error: ${response.status} ${JSON.stringify(errorBody)}`, true)
    const error = new Error(errorBody.error || `HTTP ${response.status}`)
    error.status = response.status
    error.details = errorBody
    throw error
  }

  if (response.status === 204 || response.headers.get('content-length') === '0') {
    log('API Response: Success (No Content)')
    return { status: response.status, message: 'Operation successful (no content returned).' }
  }
  if (response.status === 202) {
    log('API Response: 202 Accepted (Fast mode)')
    return { status: response.status, message: 'Request accepted for processing (Fast Mode).' }
  }

  try {
    const responseBody = await response.json()
    log(`API Response: ${response.status} Success`)
    return responseBody
  } catch (e) {
    log(`API Error: Failed to parse JSON response: ${e.message}`, true)
    const rawText = await response.text().catch(() => 'Could not read response text.')
    log(`Raw Response Text: ${rawText}`, true)
    throw new Error(`Failed to parse JSON response from LIFX API. Raw response: ${rawText}`)
  }
}

const isDisabled = (type, name) => {
  if (config.enabled && config.enabled[type] !== undefined) {
    if (name === 'all') return config.enabled[type] === false
    if (Array.isArray(config.enabled[type])) return !config.enabled[type].includes(name)
  }

  if (config.disabled && config.disabled[type] !== undefined) {
    if (name === 'all') return config.disabled[type] === true
    if (Array.isArray(config.disabled[type])) return config.disabled[type].includes(name)
  }

  if (config.enabled && config.enabled[type] === true) return false
  if (config.disabled && config.disabled[type] === false) return false

  if (config.enabled && Array.isArray(config.enabled[type])) return !config.enabled[type].includes(name)
  if (config.disabled && Array.isArray(config.disabled[type])) return config.disabled[type].includes(name)

  return false
}

const listLightsApiCall = async (selector) => {
    // Simple wrapper, no caching here
    return makeApiRequest({ method: 'GET', path: `/lights/${encodeURIComponent(selector)}` })
}

const listScenesApiCall = async () => {
    // Simple wrapper, no caching here
    return makeApiRequest({ method: 'GET', path: '/scenes' })
}

const registerResources = (server) => {
  if (!server) return log('Server not initialized, cannot register resources', true)
   if (isDisabled('resources', 'all')) {
    log('All MCP resources disabled via configuration', true)
    return
  }

  let registeredCount = 0
  const registerResource = (name, uriOrTemplate, options, handler) => {
      if (!isDisabled('resources', name)) {
          server.resource(name, uriOrTemplate, options, handler)
          registeredCount++
      } else {
         log(`Resource disabled: ${name}`)
      }
  }

  registerResource(
    'lights',
    'lifx://lights',
    { description: 'List of currently known LIFX lights and their basic status.' },
    async () => {
      return withErrorHandling(async () => {
        log('Resource: Retrieving lights list (live)...')
        const lights = await listLightsApiCall('all') // Always fetch live data
        return {
          contents: [{
            uri: 'lifx://lights',
            text: formatLightsListSummary(lights)
          }]
        }
      }, 'Error retrieving lights resource')
    }
  )

  registerResource(
    'light-state',
     new ResourceTemplate('lifx://light/{selector}/state', {
        list: async () => {
          try {
            log('Resource Template: Listing lights for state resource (live)...')
            const lights = await listLightsApiCall('all') // Always fetch live data
            return {
              resources: lights.map(light => ({
                uri: `lifx://light/id:${light.id}/state`,
                name: light.label || light.id,
                description: `State of light ${light.label || light.id}`
              }))
            }
          } catch (error) {
            log(`Error listing lights for state resource template: ${error.message}`, true)
            return { resources: [] }
          }
        },
        complete: { // Autocomplete still benefits from a recent list
          selector: async (value) => {
            try {
              log(`Resource Template: Completing selector '${value}' (live)...`)
              const lights = await listLightsApiCall('all') // Fetch for completion
              const selectors = new Set(['all'])
              lights.forEach(l => {
                selectors.add(`id:${l.id}`)
                if (l.label) selectors.add(`label:${l.label}`)
                if (l.group?.name) selectors.add(`group:${l.group.name}`)
                if (l.group?.id) selectors.add(`group_id:${l.group.id}`)
                if (l.location?.name) selectors.add(`location:${l.location.name}`)
                if (l.location?.id) selectors.add(`location_id:${l.location.id}`)
              })
              const matches = Array.from(selectors).filter(s => s.toLowerCase().includes(value.toLowerCase()))
              log(`Resource Template: Found ${matches.length} matching selectors.`)
              return matches
            } catch (error) {
              log(`Error completing selector: ${error.message}`, true)
              return []
            }
          }
        }
     }),
    { description: 'Detailed current state of a specific light or group.' },
    async (uri, { selector }) => {
      return withErrorHandling(async () => {
        log(`Resource: Retrieving state for selector '${selector}' (live)...`)
        const lights = await listLightsApiCall(selector) // Always fetch live data
        if (!lights || lights.length === 0) {
            return { contents: [{ uri: uri.href, text: `No lights found matching selector: ${selector}` }] }
        }
        return {
          contents: [{
            uri: uri.href,
            text: formatLightStateDetails(lights)
          }]
        }
      }, `Error retrieving state for selector '${selector}'`)
    }
  )

  registerResource(
    'scenes',
    'lifx://scenes',
    { description: 'List of available LIFX scenes.' },
    async () => {
      return withErrorHandling(async () => {
        log('Resource: Retrieving scenes list (live)...')
        const scenes = await listScenesApiCall() // Always fetch live data
        return {
          contents: [{
            uri: 'lifx://scenes',
            text: formatScenesListSummary(scenes)
          }]
        }
      }, 'Error retrieving scenes resource')
    }
  )

  log(`Total MCP resources registered: ${registeredCount}`)
}

const registerPrompts = (server) => {
    if (!server) return log('Server not initialized, cannot register prompts', true)
    if (isDisabled('prompts', 'all')) {
      log('All MCP prompts disabled via configuration', true)
      return
    }

    let registeredCount = 0
    const registerPrompt = (name, description, schema, handler) => {
        if (!isDisabled('prompts', name)) {
            server.prompt(name, description, schema, handler)
            registeredCount++
        } else {
           log(`Prompt disabled: ${name}`)
        }
    }

    registerPrompt(
        'effect-creator',
        'Guides you through creating parameters for a LIFX light effect.',
        {
          effect_type: z.enum(['breathe', 'pulse', 'move', 'morph', 'flame', 'clouds', 'sunrise', 'sunset']).describe('The type of effect to create.'),
          selector: z.string().min(1).describe('The light selector (e.g., "all", "label:Lamp").'),
          description: z.string().min(1).describe('Describe the desired effect in natural language (e.g., "a slow red pulse", "fast rainbow morph").')
        },
        async ({ effect_type, selector, description }) => {
            log(`Prompt: effect-creator for ${effect_type} on '${selector}' described as "${description}"`)
            let toolCommand = `${effect_type}-effect {\n  "selector": "${selector}"`
            const descLower = description.toLowerCase()
            const colors = ['red', 'green', 'blue', 'yellow', 'orange', 'purple', 'pink', 'cyan', 'white']
            let foundColor = null
            for (const c of colors) { if (descLower.includes(c)) { foundColor = c; break } }
            if (foundColor) toolCommand += `,\n  "color": "${foundColor}"`
            if (descLower.includes('slow')) toolCommand += `,\n  "period": 5.0`
            else if (descLower.includes('fast')) toolCommand += `,\n  "period": 0.5`
            if (descLower.includes('forever') || descLower.includes('indefinite')) {
                 if (effect_type !== 'breathe' && effect_type !== 'pulse') toolCommand += `\n  // Note: Omitting duration/cycles implies indefinite for ${effect_type}.`
                 else toolCommand += `,\n  "cycles": 0`
            }
            toolCommand += `\n}`
            return {
                description: `Create a ${effect_type} effect`,
                messages: [{ role: 'user', content: { type: 'text', text: `Okay, let's create a '${effect_type}' effect for the selector '${selector}' based on your description: "${description}".\n\nI've tried to generate a starting command. Please review and adjust the parameters as needed, referring to the documentation for the specific effect:\n\n\`\`\`\n${toolCommand}\n\`\`\`\n\nKey parameters to consider for '${effect_type}':\n- **color/palette:** Define the colors used.\n- **period:** Controls the speed (seconds per cycle).\n- **cycles/duration:** How long the effect runs (0 or omitted can mean indefinite for some effects).\n- **persist/power_on/fast:** Common effect options.\n- *Specific parameters:* Check '${effect_type}-effect' tool docs for unique options (like 'peak', 'direction', 'min_saturation').\n\nModify the command above and execute it when ready.` } }]
            }
        }
    )

    registerPrompt(
        'troubleshooter',
        'Helps diagnose issues with unresponsive lights.',
        {
            selector: z.string().default('all').describe('Selector for the light(s) having issues (e.g., "label:Problem Lamp", "id:d073d...")')
        },
        async ({ selector }) => {
            log(`Prompt: troubleshooter for selector '${selector}'`)
            let analysis = `Troubleshooting for selector: ${selector}\n\n`
            let recommendation = 'Next Steps:\n'
            try {
                const lights = await listLightsApiCall(selector) // Fetch live data
                if (lights.length === 0) {
                    analysis += `- No lights found matching selector '${selector}'. Please verify the selector.\n`
                    recommendation += `- Use the 'selector-helper' prompt to find the correct selector.\n`
                } else {
                    analysis += `Found ${lights.length} light(s). Checking status:\n`
                    let allConnected = true
                    let allPoweredOn = true
                    lights.forEach(light => {
                        analysis += `- ${light.label || light.id}: Connected: ${light.connected}, Power: ${light.power}\n`
                        if (!light.connected) allConnected = false
                        if (light.power !== 'on') allPoweredOn = false
                    })

                    if (allConnected && allPoweredOn) {
                        analysis += "\nAll selected lights appear to be connected and powered on according to the API."
                        recommendation += `- Try a simple command like 'set state selector:${selector} power:on brightness:0.5'.\n`
                        recommendation += `- Check your Wi-Fi network and ensure the lights haven't lost connection locally.\n`
                        recommendation += `- Try power cycling the problematic light(s).\n`
                    } else {
                        if (!allConnected) {
                            analysis += `\nOne or more lights are disconnected from the LIFX cloud.\n`
                            recommendation += `- Check physical power and Wi-Fi.\n`
                            recommendation += `- Power cycle the light(s).\n`
                            recommendation += `- If issues persist, use the LIFX app for reset/re-onboarding.\n`
                        }
                        if (allConnected && !allPoweredOn) {
                            analysis += `\nSome lights are connected but reported as off.\n`
                            recommendation += `- Try turning them on: 'set state selector:${selector} power:on'.\n`
                        }
                    }
                }
            } catch (error) {
                analysis += `Error fetching light status: ${error.message}\n`
                recommendation += `- Verify your API token is correct.\n`
                recommendation += `- Check LIFX Cloud status: https://status.lifx.com\n`
            }
            return { description: `Troubleshoot LIFX Lights`, messages: [ { role: 'user', content: { type: 'text', text: analysis + '\n' + recommendation } } ] }
        }
    )

   registerPrompt(
        'selector-helper',
        'Helps you build the right selector to target specific lights.',
        {
            goal: z.string().optional().describe('Describe the light(s) you want to target (e.g., "kitchen lights", "the desk lamp").')
        },
        async ({ goal }) => {
            log(`Prompt: selector-helper for goal "${goal || 'list all identifiers'}"`)
            let output = "Let's find the right selector.\n\n"
            try {
                const lights = await listLightsApiCall('all') // Fetch live data
                if (lights.length === 0) {
                   output += 'No lights found in your account.'
                } else {
                    const uniqueLabels = [...new Set(lights.map(l => l.label).filter(Boolean))]
                    const uniqueGroups = [...new Set(lights.map(l => l.group?.name).filter(Boolean))]
                    const uniqueGroupIds = [...new Set(lights.map(l => l.group?.id).filter(Boolean))]
                    const uniqueLocations = [...new Set(lights.map(l => l.location?.name).filter(Boolean))]
                    const uniqueLocationIds = [...new Set(lights.map(l => l.location?.id).filter(Boolean))]
                    const allIds = lights.map(l => l.id)

                    output += `Available Identifiers (Live Data):\n`
                    if (uniqueLabels.length > 0) output += `- Labels: ${uniqueLabels.map(l => `"${l}"`).join(', ')} (Use: \`label:"${uniqueLabels[0]}"\`)\n`
                    if (uniqueGroups.length > 0) output += `- Group Names: ${uniqueGroups.map(g => `"${g}"`).join(', ')} (Use: \`group:"${uniqueGroups[0]}"\`)\n`
                    if (uniqueLocations.length > 0) output += `- Location Names: ${uniqueLocations.map(l => `"${l}"`).join(', ')} (Use: \`location:"${uniqueLocations[0]}"\`)\n`
                    if (allIds.length > 0) output += `- IDs: ${allIds.slice(0, 3).join(', ')}... (Use: \`id:${allIds[0]}\`)\n`
                    if (uniqueGroupIds.length > 0) output += `- Group IDs: ${uniqueGroupIds.slice(0,3).join(', ')}... (Use: \`group_id:${uniqueGroupIds[0]}\`)\n`
                    if (uniqueLocationIds.length > 0) output += `- Location IDs: ${uniqueLocationIds.slice(0,3).join(', ')}... (Use: \`location_id:${uniqueLocationIds[0]}\`)\n`

                    output += `\nCommon Selectors:\n`
                    output += `- \`all\`: Targets every light.\n`
                    output += `- \`id:<light_id>\`, \`label:"Your Label"\`, \`group:"Group Name"\`, \`location:"Location Name"\`, \`group_id:<group_uuid>\`, \`location_id:<location_uuid>\`\n`
                    output += `- Combine selectors with commas, e.g., \`label:Lamp,group:Office\`\n`

                    if (goal) {
                        output += `\nBased on your goal "${goal}", potential selectors might be:\n`
                        const goalLower = goal.toLowerCase()
                        let suggested = false
                         uniqueLabels.forEach(l => { if (goalLower.includes(l.toLowerCase())) { output += `- \`label:"${l}"\`\n`; suggested = true } })
                        uniqueGroups.forEach(g => { if (goalLower.includes(g.toLowerCase())) { output += `- \`group:"${g}"\`\n`; suggested = true } })
                        uniqueLocations.forEach(loc => { if (goalLower.includes(loc.toLowerCase())) { output += `- \`location:"${loc}"\`\n`; suggested = true } })
                        if (!suggested) output += `- Try using one of the identifiers listed above.\n`
                    }
                }
            } catch (error) {
                output += `Error fetching light identifiers: ${error.message}\n`
            }
             return { description: `Help with LIFX Selectors`, messages: [ { role: 'user', content: { type: 'text', text: output } } ] }
        }
    )

    log(`Total MCP prompts registered: ${registeredCount}`)
}

const registerTools = (server) => {
  if (!server) return log('Server not initialized, cannot register tools', true)
  if (isDisabled('tools', 'all')) {
    log('All MCP tools disabled via configuration', true)
    return
  }

  let registeredCount = 0
  const registerTool = (name, description, schema, handler) => {
    if (!isDisabled('tools', name)) {
      server.tool(name, description, schema, handler)
      registeredCount++
    } else {
      log(`Tool disabled: ${name}`)
    }
  }

  registerTool(
    'list-lights',
    'Gets lights belonging to the account. Filter using selectors.',
    { selector: z.string().default('all').describe('The selector (e.g., all, id:d073d5..., label:Lamp).') },
    async ({ selector }) => {
      return withErrorHandling(async () => {
        const lights = await listLightsApiCall(selector) // Use API call function
        return { content: [{ type: 'text', text: formatLightsList(lights) }] }
      }, 'Error listing lights')
    }
  )

  registerTool(
    'set-state',
    'Sets the state of the lights within the selector. All parameters are optional.',
    {
      selector: z.string().min(1).describe('The selector.'),
      power: z.enum(['on', 'off']).optional().describe('Power state.'),
      color: z.string().optional().describe('Color string (e.g., red, kelvin:3500).'),
      brightness: z.number().min(0).max(1).optional().describe('Brightness 0.0-1.0.'),
      duration: z.number().min(0).optional().describe('Transition duration (s).'),
      infrared: z.number().min(0).max(1).optional().describe('Infrared brightness 0.0-1.0.'),
      fast: createBooleanSchema('Execute fast.', 'false')
    },
    async ({ selector, fast, ...state }) => {
      return withErrorHandling(async () => {
        const body = _.omitBy(state, _.isUndefined)
        body.fast = fast === 'true'
        const result = await makeApiRequest({ method: 'PUT', path: `/lights/${encodeURIComponent(selector)}/state`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error setting state')
    }
  )

  registerTool(
    'set-states',
    'Set multiple states across multiple selectors in a single request.',
    {
      states: z.string().min(1).describe('JSON array of state objects (selector + state). Max 50.'),
      defaults: z.string().optional().describe('JSON object of default state properties.'),
      fast: createBooleanSchema('Execute fast.', 'false')
    },
    async ({ states, defaults, fast }) => {
      return withErrorHandling(async () => {
        const parsedStates = parseJsonString(states)
        if (!Array.isArray(parsedStates) || parsedStates.length === 0 || parsedStates.length > 50) throw new Error('States must be JSON array [1-50].')
        const body = { states: parsedStates, fast: fast === 'true' }
        if (defaults) body.defaults = parseJsonString(defaults)
        const result = await makeApiRequest({ method: 'PUT', path: '/lights/states', body })
        return { content: [{ type: 'text', text: formatSetStatesResponse(result) }] }
      }, 'Error setting multiple states')
    }
  )

  registerTool(
    'state-delta',
    'Change state properties by a relative amount.',
    {
      selector: z.string().min(1).describe('The selector.'),
      power: z.enum(['on', 'off']).optional().describe('Set power state (absolute).'),
      duration: z.number().min(0).optional().describe('Transition duration (s).'),
      hue: z.number().min(-360).max(360).optional().describe('Rotate hue (degrees).'),
      saturation: z.number().min(-1).max(1).optional().describe('Change saturation (+/-).'),
      brightness: z.number().min(-1).max(1).optional().describe('Change brightness (+/-).'),
      kelvin: z.number().int().optional().describe('Change kelvin (+/-).'),
      infrared: z.number().min(-1).max(1).optional().describe('Change infrared (+/-).'),
      fast: createBooleanSchema('Execute fast.', 'false')
    },
    async ({ selector, fast, ...delta }) => {
      return withErrorHandling(async () => {
        const body = _.omitBy(delta, _.isUndefined)
        body.fast = fast === 'true'
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/state/delta`, body })
         return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error applying state delta')
    }
  )

  registerTool(
    'toggle-power',
    'Turn lights off if any are on, or on if all are off.',
    {
      selector: z.string().min(1).describe('The selector.'),
      duration: z.number().min(0).default(1.0).describe('Transition duration (s).')
    },
    async ({ selector, duration }) => {
      return withErrorHandling(async () => {
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/toggle`, body: { duration } })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error toggling power')
    }
  )

  // --- Effects ---
  const effectSchemaBase = {
      selector: z.string().min(1).describe('Selector for the lights/device.'),
      period: z.number().optional().describe('Time in seconds for one cycle.'),
      cycles: z.number().optional().describe('Number of cycles to repeat.'),
      power_on: createBooleanSchema('Turn the light on if it is off.', 'true'),
      // Note: `fast` is not documented for most effect endpoints, only state changes
  }

  registerTool(
    'breathe-effect',
    'Performs a breathe effect by slowly fading between colors.',
     { ...effectSchemaBase,
       color: z.string().min(1).describe('The color to breathe.'),
       from_color: z.string().optional().describe('Color to start from (defaults to current color).'),
       persist: createBooleanSchema('Leave the light end color when effect ends.', 'false'),
       peak: z.number().min(0).max(1).default(0.5).describe('Position in cycle of maximum color (0-1).')
     },
    async ({ selector, period = 1.0, cycles = 1.0, ...effectParams }) => { // Add defaults here
      return withErrorHandling(async () => {
        const body = _.omitBy({ ...effectParams, period, cycles }, _.isUndefined)
        body.persist = body.persist === 'true'
        body.power_on = body.power_on === 'true'
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/effects/breathe`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error starting breathe effect')
    }
  )

  registerTool(
    'pulse-effect',
    'Performs a pulse effect by quickly flashing between colors.',
    { ...effectSchemaBase,
      color: z.string().min(1).describe('The color to pulse.'),
      from_color: z.string().optional().describe('Color to start from (defaults to current color).'),
      persist: createBooleanSchema('Leave the light end color when effect ends.', 'false'),
    },
    async ({ selector, period = 1.0, cycles = 1.0, ...effectParams }) => { // Add defaults here
      return withErrorHandling(async () => {
        const body = _.omitBy({ ...effectParams, period, cycles }, _.isUndefined)
        body.persist = body.persist === 'true'
        body.power_on = body.power_on === 'true'
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/effects/pulse`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error starting pulse effect')
    }
  )

  registerTool(
    'move-effect',
    'Performs a move effect on linear devices (LIFX Z strips).',
    { selector: z.string().min(1).describe('Selector for the linear device.'),
      direction: z.enum(['forward', 'backward']).default('forward').describe('Move direction.'),
      period: z.number().default(1.0).describe('Time (s) for one cycle.'),
      cycles: z.number().optional().describe('Number of cycles (0=stop, omit=indefinite).'),
      power_on: createBooleanSchema('Turn on if off.', 'true'),
      fast: createBooleanSchema('Execute fast.', 'false') // This effect DOES support fast
    },
    async ({ selector, ...effectParams }) => {
      return withErrorHandling(async () => {
        const body = _.omitBy(effectParams, _.isUndefined)
        body.power_on = body.power_on === 'true'
        body.fast = body.fast === 'true'
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/effects/move`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error starting move effect')
    }
  )

  registerTool(
    'morph-effect',
    'Performs a morph effect on Tile devices.',
    { selector: z.string().min(1).describe('Selector for the Tile device.'),
      period: z.number().default(5.0).describe('Cycle time (s, lower=faster).'),
      duration: z.number().optional().describe('Duration (s, 0=stop, omit=indefinite).'),
      palette: z.string().optional().describe('JSON array of color strings. Defaults to 7 colors.'),
      power_on: createBooleanSchema('Turn on if off.', 'true'),
      fast: createBooleanSchema('Execute fast.', 'false') // This effect DOES support fast
    },
    async ({ selector, palette, ...effectParams }) => {
      return withErrorHandling(async () => {
        const body = _.omitBy(effectParams, _.isUndefined)
        if (palette) body.palette = parseJsonString(palette)
        if (body.palette && !Array.isArray(body.palette)) throw new Error('Palette must be JSON array.')
        body.power_on = body.power_on === 'true'
        body.fast = body.fast === 'true'
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/effects/morph`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error starting morph effect')
    }
  )

  registerTool(
    'flame-effect',
    'Performs a flame effect on Tile devices.',
     { selector: z.string().min(1).describe('Selector for the Tile device.'),
       period: z.number().default(5.0).describe('Cycle time (s, lower=faster).'),
       duration: z.number().optional().describe('Duration (s, 0=stop, omit=indefinite).'),
       power_on: createBooleanSchema('Turn on if off.', 'true'),
       fast: createBooleanSchema('Execute fast.', 'false') // This effect DOES support fast
     },
    async ({ selector, ...effectParams }) => {
      return withErrorHandling(async () => {
        const body = _.omitBy(effectParams, _.isUndefined)
        body.power_on = body.power_on === 'true'
        body.fast = body.fast === 'true'
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/effects/flame`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error starting flame effect')
    }
  )

  registerTool(
    'clouds-effect',
    'Performs a clouds effect on Tile devices (FW >= 4.8).',
    { selector: z.string().min(1).describe('Selector for the Tile device.'),
      period: z.number().default(50.0).describe('Cycle time (s, lower=faster).'),
      duration: z.number().optional().describe('Duration (s, 0=stop, omit=indefinite).'),
      power_on: createBooleanSchema('Turn on if off.', 'true'),
      min_saturation: z.number().min(0).max(1).default(0.2).describe('Min saturation (0-1).'),
      fast: createBooleanSchema('Execute fast.', 'false') // This effect DOES support fast
    },
    async ({ selector, ...effectParams }) => {
      return withErrorHandling(async () => {
        const body = _.omitBy(effectParams, _.isUndefined)
        body.power_on = body.power_on === 'true'
        body.fast = body.fast === 'true'
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/effects/clouds`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error starting clouds effect')
    }
  )

  registerTool(
    'sunrise-effect',
    'Performs a sunrise effect on Tile devices (FW >= 4.8).',
    { selector: z.string().min(1).describe('Selector for the Tile device.'),
      duration: z.number().default(10.0).describe('Duration (s, 0=stop).'),
      persist: createBooleanSchema('Persist final color.', 'false'),
      power_on: createBooleanSchema('Turn on if off.', 'true'),
      fast: createBooleanSchema('Execute fast.', 'false') // This effect DOES support fast
    },
    async ({ selector, ...effectParams }) => {
      return withErrorHandling(async () => {
        const body = _.omitBy(effectParams, _.isUndefined)
        body.persist = body.persist === 'true'
        body.power_on = body.power_on === 'true'
        body.fast = body.fast === 'true'
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/effects/sunrise`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error starting sunrise effect')
    }
  )

  registerTool(
    'sunset-effect',
    'Performs a sunset effect on Tile devices (FW >= 4.8).',
    { selector: z.string().min(1).describe('Selector for the Tile device.'),
      duration: z.number().default(10.0).describe('Duration (s, 0=stop).'),
      soft_off: createBooleanSchema('Perform soft off after.', 'false'),
      power_on: createBooleanSchema('Turn on if off.', 'true'),
      fast: createBooleanSchema('Execute fast.', 'false') // This effect DOES support fast
    },
    async ({ selector, ...effectParams }) => {
      return withErrorHandling(async () => {
        const body = _.omitBy(effectParams, _.isUndefined)
        body.soft_off = body.soft_off === 'true'
        body.power_on = body.power_on === 'true'
        body.fast = body.fast === 'true'
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/effects/sunset`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error starting sunset effect')
    }
  )

  registerTool(
    'effects-off',
    'Turns off any running effects on the specified lights.',
    {
      selector: z.string().min(1).describe('Selector to limit which lights this applies to.'),
      power_off: createBooleanSchema('Also turn the lights off.', 'false')
    },
    async ({ selector, power_off }) => {
      return withErrorHandling(async () => {
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/effects/off`, body: { power_off: power_off === 'true' } })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error turning effects off')
    }
  )

  // --- Scenes ---
  registerTool(
    'list-scenes',
    'Lists all scenes in the users account.',
    async () => {
      return withErrorHandling(async () => {
        const scenes = await listScenesApiCall() // Use API call function
        return { content: [{ type: 'text', text: formatScenesList(scenes) }] }
      }, 'Error listing scenes')
    }
  )

  registerTool(
    'activate-scene',
    'Activates a scene.',
    {
      scene_uuid: z.string().min(1).describe('The UUID of the scene to activate.'),
      duration: z.number().min(0).default(1.0).describe('Transition duration (s).'),
      ignore: z.string().optional().describe('Comma-separated properties to ignore (power, color, etc.).'),
      fast: createBooleanSchema('Execute fast.', 'false')
    },
    async ({ scene_uuid, duration, ignore, fast }) => {
      return withErrorHandling(async () => {
        const body = { duration, fast: fast === 'true' }
        if (ignore) body.ignore = ignore.split(',').map(s => s.trim())
        const result = await makeApiRequest({ method: 'PUT', path: `/scenes/scene_id:${scene_uuid}/activate`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error activating scene')
    }
  )

  // --- Other ---
  registerTool(
    'cycle',
    'Cycle lights through a list of states.',
    {
      selector: z.string().min(1).describe('The selector.'),
      states: z.string().min(1).describe('JSON array of state objects. Must have 2-10 entries.'),
      direction: z.enum(['forward', 'backward']).default('forward').describe('Direction to cycle.')
    },
    async ({ selector, states, direction }) => {
      return withErrorHandling(async () => {
        const parsedStates = parseJsonString(states)
        if (!Array.isArray(parsedStates) || parsedStates.length < 2 || parsedStates.length > 10) throw new Error('States must be JSON array [2-10].')
        const body = { states: parsedStates, direction }
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/cycle`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result) }] }
      }, 'Error cycling states')
    }
  )

  registerTool(
    'validate-color',
    'Validates a color string and returns its components.',
    { string: z.string().min(1).describe('The color string to validate.') },
    async ({ string }) => {
      return withErrorHandling(async () => {
        const result = await makeApiRequest({ method: 'GET', path: '/color', query: { string } })
        return { content: [{ type: 'text', text: `Color Validation:\nInput: ${string}\nResult: ${JSON.stringify(result, null, 2)}` }] }
      }, 'Error validating color')
    }
  )

  registerTool(
    'clean',
    'Control clean-capable LIFX devices (LIFX Clean).',
    {
      selector: z.string().min(1).describe('Selector for the clean-capable device.'),
      stop: createBooleanSchema('Stop the cleaning cycle.', 'false'),
      duration: z.number().int().min(0).optional().describe('Duration (s, 0=device default).')
    },
    async ({ selector, stop, duration }) => {
      return withErrorHandling(async () => {
        const body = { stop: stop === 'true' }
        if (duration !== undefined && duration !== null) body.duration = duration
        const result = await makeApiRequest({ method: 'POST', path: `/lights/${encodeURIComponent(selector)}/clean`, body })
        return { content: [{ type: 'text', text: formatResultsResponse(result, 'Clean operation') }] }
      }, 'Error controlling clean function')
    }
  )

  log(`Total MCP tools registered: ${registeredCount}`)
}

const withErrorHandling = async (operation, errorMessage) => {
  try {
    return await operation()
  } catch (error) {
    const status = error.status || 500
    const details = error.details || { error: error.message }
    const lifxError = (typeof details === 'object' && details !== null && details.error) ? details.error : error.message
    const fullMessage = `${errorMessage}: ${lifxError} (HTTP ${status})`
    log(fullMessage, true)
    if (typeof details === 'object' && details !== null) log(`Error Details: ${JSON.stringify(details)}`, true)
    let errorCode = JSONRPC_ERROR_CODES.SERVER_ERROR_START
    if (status === 400) errorCode = JSONRPC_ERROR_CODES.INVALID_REQUEST
    else if (status === 401) errorCode = JSONRPC_ERROR_CODES.LIFX_AUTH_ERROR
    else if (status === 403) errorCode = JSONRPC_ERROR_CODES.LIFX_PERMISSION_ERROR
    else if (status === 404) errorCode = JSONRPC_ERROR_CODES.LIFX_SELECTOR_ERROR
    else if (status === 422) errorCode = JSONRPC_ERROR_CODES.INVALID_PARAMS
    else if (status === 426) errorCode = JSONRPC_ERROR_CODES.LIFX_UPGRADE_REQUIRED
    else if (status === 429) errorCode = JSONRPC_ERROR_CODES.LIFX_RATE_LIMIT
    else if (status >= 500) errorCode = JSONRPC_ERROR_CODES.LIFX_SERVER_ERROR
    return { content: [{ type: 'text', text: fullMessage }], isError: true, error: { code: errorCode, message: lifxError, data: { httpStatus: status, details } } }
  }
}

// --- Formatting Helpers ---
const formatLightsList = (lights) => {
  if (!Array.isArray(lights)) return 'Invalid response format for lights list.'
  if (lights.length === 0) return 'No lights found matching the selector.'
  let output = `Found ${lights.length} light(s):\n\n`
  lights.forEach(light => {
    output += `Label: ${light.label || 'N/A'}\n`
    output += `ID: ${light.id}\n`
    output += `Power: ${light.power}\n`
    output += `Connected: ${light.connected}\n`
    const color = light.color || {}
    const hue = color.hue !== undefined ? color.hue.toFixed(1) : 'N/A'
    const saturation = color.saturation !== undefined ? color.saturation.toFixed(2) : 'N/A'
    const kelvin = color.kelvin !== undefined ? color.kelvin : 'N/A'
    const brightness = light.brightness !== undefined ? light.brightness.toFixed(2) : 'N/A'
    output += `Color: H:${hue}, S:${saturation}, B:${brightness}, K:${kelvin}\n`
    if (light.group) output += `Group: ${light.group.name} (ID: ${light.group.id})\n`
    if (light.location) output += `Location: ${light.location.name} (ID: ${light.location.id})\n`
    if (light.product) {
      const fw = light.firmware_version || 'N/A'
      output += `Product: ${light.product.name} (FW: ${fw})\n`
      if (light.product.capabilities) {
          if (light.product.capabilities.has_ir) output += `Infrared: Yes (Max: ${light.infrared?.brightness?.toFixed(2) || 'N/A'})\n`
          if (light.product.capabilities.has_multizone) output += `Multizone: Yes\n`
          if (light.product.capabilities.has_variable_color_temp) output += `Variable Temp: Yes\n`
          if (light.product.capabilities.has_hev) output += `Clean (HEV): Yes\n`
      }
    }
    if (light.effect && light.effect !== 'OFF') output += `Effect: ${light.effect}\n`
    output += '---\n'
  })
  return output
}

const formatLightsListSummary = (lights) => {
  if (!Array.isArray(lights) || lights.length === 0) return 'No lights available.'
  let output = `Available Lights (${lights.length}):\n`
  lights.forEach(l => output += `- ${l.label || l.id} (ID: ${l.id}, Power: ${l.power}, Connected: ${l.connected})\n`)
  return output
}

const formatLightStateDetails = (lights) => {
    if (!Array.isArray(lights)) return 'Invalid light state data.'
    if (lights.length === 0) return 'No light state found for the given selector.'
    return formatLightsList(lights)
}

const formatScenesListSummary = (scenes) => {
  if (!Array.isArray(scenes) || scenes.length === 0) return 'No scenes available.'
  let output = `Available Scenes (${scenes.length}):\n`
  scenes.forEach(s => output += `- ${s.name} (UUID: ${s.uuid})\n`)
  return output
}

const formatScenesList = (scenes) => {
  if (!Array.isArray(scenes)) return 'Invalid response format for scenes list.'
  if (scenes.length === 0) return 'No scenes found in your account.'
  let output = `Found ${scenes.length} scene(s):\n\n`
  scenes.forEach(scene => {
    output += `Name: ${scene.name}\n`
    output += `UUID: ${scene.uuid}\n`
    output += `States: ${scene.states?.length || 0}\n`
    const createdAt = scene.created_at ? new Date(scene.created_at * 1000).toLocaleString() : 'N/A'
    const updatedAt = scene.updated_at ? new Date(scene.updated_at * 1000).toLocaleString() : 'N/A'
    output += `Created: ${createdAt}\n`
    output += `Updated: ${updatedAt}\n`
    output += '---\n'
  })
  return output
}

const formatResultsResponse = (response, operation = 'Operation') => {
  if (!response) return `${operation} failed: No response from API.`
  if (response.status === 202) return response.message
  if (response.status === 204) return response.message
  let resultsArray = null
  if (response.results && Array.isArray(response.results)) resultsArray = response.results
  else if (Array.isArray(response)) resultsArray = response
  if (resultsArray) {
    if (resultsArray.length === 0) return `${operation} completed, but no specific results returned or no lights matched the selector.`
    let output = `${operation} results (${resultsArray.length} item(s)):\n`
    resultsArray.forEach(res => {
      if (res.id && res.status) {
        output += `- ID: ${res.id}`
        if (res.label) output += ` (${res.label})`
        output += `: ${res.status}\n`
      } else output += `- ${JSON.stringify(res)}\n`
    })
     if (response.warnings) output += `\nWarnings:\n${JSON.stringify(response.warnings, null, 2)}`
    return output
  }
  if (typeof response === 'object' && response !== null) {
    if (response.message) return response.message
    if (operation === 'Clean operation' && Object.keys(response).length === 0) return 'Clean operation successful.'
    return `${operation} successful. Response data:\n${JSON.stringify(response, null, 2)}`
  }
  return `${operation} completed with unexpected response: ${response}`
}

const formatSetStatesResponse = (response) => {
  if (!response) return 'Set States operation failed: No response.'
   if (response.status === 202) return response.message
  if (!response.results || !Array.isArray(response.results)) return formatResultsResponse(response, 'Set Multiple States')
  let output = 'Set Multiple States Results:\n\n'
  response.results.forEach((opResult, index) => {
    output += `Operation ${index + 1}:\n`
    if (opResult.operation && opResult.results) {
      output += `  Selector: ${opResult.operation.selector || 'Unknown'}\n`
      if (opResult.results.length > 0) {
        opResult.results.forEach(lightRes => {
          output += `  - ID: ${lightRes.id}`
          if (lightRes.label) output += ` (${lightRes.label})`
          output += `: ${lightRes.status}\n`
        })
      } else output += '  - No lights matched this operation\'s selector.\n'
    } else output += `  Result: ${JSON.stringify(opResult)}\n`
    output += '---\n'
  })
   if (response.warnings) output += `\nWarnings:\n${JSON.stringify(response.warnings, null, 2)}`
  return output
}

// --- Config Loading & Utils ---
const loadConfig = () => {
  let loadedConfig = { ...defaultConfig }
  const configPathEnv = process.env.CONFIG_PATH
  let configPath = null
  if (configPathEnv) configPath = configPathEnv
  else {
    const homeDir = process.env.HOME || process.env.USERPROFILE || __dirname
    const jsoncPath = join(homeDir, '.lifx-api-mcp-server.jsonc')
    const jsonPath = join(homeDir, '.lifx-api-mcp-server.json')
    if (existsSync(jsoncPath)) configPath = jsoncPath
    else if (existsSync(jsonPath)) configPath = jsonPath
  }
  if (configPath && existsSync(configPath)) {
    try {
      log(`Loading config file: ${configPath}`)
      const fileContent = readFileSync(configPath, 'utf8')
      const strippedContent = stripJsonComments(fileContent)
      const configFile = JSON.parse(strippedContent)
      loadedConfig = mergeConfigs(loadedConfig, configFile)
    } catch (error) { console.error(`Error loading config file (${configPath}): ${error.message}`) }
  } else log('No config file found, using defaults.')
  loadedConfig = applyEnvOverrides(loadedConfig)
  return loadedConfig
}

const mergeConfigs = (target, source) => _.merge({}, target, source)
const applyEnvOverrides = (configToOverride) => {
  const result = { ...configToOverride }
  const mapping = createEnvMapping(configToOverride)
  Object.entries(mapping).forEach(([configPath, envKey]) => {
    if (process.env[envKey] === undefined) return
    const defaultValue = getValueAtPath(configToOverride, configPath)
    const value = parseEnvValue(process.env[envKey], defaultValue, configPath)
    setValueAtPath(result, configPath, value)
  })
  return result
}
const createEnvMapping = (obj, prefix = 'CONFIG', path = '') => {
  let mapping = {}
  Object.entries(obj).forEach(([key, value]) => {
    const currentPath = path ? `${path}.${key}` : key
    const snakeKey = key.replace(/([A-Z])/g, '_$1').toUpperCase()
    const envKey = `${prefix}_${snakeKey}`
    if (typeof value === 'object' && value !== null && !Array.isArray(value) && (path === '' || path === 'disabled' || path === 'enabled')) {
      const nestedMapping = createEnvMapping(value, `${prefix}_${snakeKey}`, currentPath)
      mapping = { ...mapping, ...nestedMapping }
    } else if (!currentPath.includes('.') || path === 'disabled' || path === 'enabled') {
       mapping[currentPath] = envKey
    }
  })
  return mapping
}
const parseEnvValue = (value, defaultValue, path) => {
  try {
    const normalizedValue = value.trim().replace(/^['"]|['"]$/g, '')
    if (typeof defaultValue === 'boolean') {
      const cleanBool = normalizedValue.toLowerCase()
      if (cleanBool !== 'true' && cleanBool !== 'false') throw new Error(`Invalid boolean`)
      return cleanBool === 'true'
    }
    if (path === 'logLevel' && !['info', 'verbose'].includes(normalizedValue.toLowerCase())) throw new Error(`Invalid logLevel`)
    // Simplified parsing for disabled/enabled arrays/booleans
    if (path.startsWith('disabled.') || path.startsWith('enabled.')) {
         const cleanBool = normalizedValue.toLowerCase()
         if (cleanBool === 'true') return true
         if (cleanBool === 'false') return false
         // Assume comma-separated list otherwise
         return normalizedValue.split(',').map(item => item.trim()).filter(Boolean)
    }
    return normalizedValue
  } catch (error) { console.error(`Error parsing env var for config [${path}]: ${error.message}. Using default: ${defaultValue}`); return defaultValue }
}
const getValueAtPath = (obj, path) => _.get(obj, path)
const setValueAtPath = (obj, path, value) => _.set(obj, path, value)
const getPackageVersion = () => {
  if (packageVersion) return packageVersion
  try { const pkg = JSON.parse(readFileSync(join(__dirname, 'package.json'), 'utf8')); packageVersion = pkg.version; return packageVersion }
  catch (error) { log(`Error reading package.json: ${error.message}`, true); packageVersion = '0.0.0'; return packageVersion }
}
const createBooleanSchema = (description, defaultValue = 'false') => z.string().transform(v => v?.toLowerCase()).pipe(z.enum(['true', 'false'])).default(defaultValue).describe(description)
const parseJsonString = (jsonString) => { try { return JSON.parse(jsonString) } catch (error) { throw new Error(`Invalid JSON: ${error.message}`) } }
const log = (message, forceLog = false) => { if (forceLog || (config && config.logLevel === 'verbose')) console.error(`[LIFX MCP] ${message}`) }
const cleanup = async () => { if (server) await server.close().catch(e => log(`Server close error: ${e.message}`, true)); if (transport) await transport.close().catch(e => log(`Transport close error: ${e.message}`, true)) }
const setupSignalHandlers = () => { process.on('SIGTERM', async () => { log('SIGTERM', true); await cleanup(); exit() }); process.on('SIGINT', async () => { log('SIGINT', true); await cleanup(); exit() }) }
const exit = (exitCode = 0) => { log(`Exiting with code ${exitCode}`, true); process.exit(exitCode) }

// --- Globals ---
let server = null, transport = null, apiToken = null, config = null, packageVersion = null
const defaultConfig = { apiToken: null, logLevel: 'info', disabled: {}, enabled: {} } // Removed cache config
const JSONRPC_ERROR_CODES = { PARSE_ERROR: -32700, INVALID_REQUEST: -32600, METHOD_NOT_FOUND: -32601, INVALID_PARAMS: -32602, INTERNAL_ERROR: -32603, SERVER_ERROR_START: -32000, LIFX_AUTH_ERROR: -32050, LIFX_PERMISSION_ERROR: -32051, LIFX_SELECTOR_ERROR: -32052, LIFX_UPGRADE_REQUIRED: -32053, LIFX_RATE_LIMIT: -32054, LIFX_SERVER_ERROR: -32055 }
const instructions = `
LIFX-HTTP-API-MCP-Server: NL→LIFX API via MCP (v${getPackageVersion()})

RESOURCES:
- lifx://lights: Overview of lights (live data)
- lifx://light/{selector}/state: Detailed state for specific light(s) (live data)
- lifx://scenes: List of available scenes (live data)

PROMPTS:
- effect-creator: Guides creating effect commands.
- troubleshooter: Basic diagnostics for unresponsive lights.
- selector-helper: Lists identifiers to help build selectors.

TOOLS: list-lights, set-state, set-states, state-delta, toggle-power, breathe-effect, pulse-effect, move-effect, morph-effect, flame-effect, clouds-effect, sunrise-effect, sunset-effect, effects-off, list-scenes, activate-scene, cycle, validate-color, clean

SELECTORS: all, id:<id>, label:<label>, group:<group>, location:<location>, scene_id:<scene_id>, group_id:<gid>, location_id:<lid> (Comma-separated for multiple)

COLORS: red, blue, #ff00ff, hue:120, kelvin:4000, saturation:0.8, brightness:0.5

CONFIG: Token via ~/.lifx-api-mcp-server.jsonc, CONFIG_API_TOKEN, or CLI arg. Disable/enable features in config. See README.
`

setupSignalHandlers()
start(process.argv[2])
